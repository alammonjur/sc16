\section{Conclusions}

In this paper, we propose a hardware realization of a priority queue that is based on a binary heap.
The heap is implemented in a pipelined fashion in hardware.
Our design takes $O(1)$ time for all operations by ensuring minimum wait time between two consecutive operations.
We propose two techniques for hardware optimization: hole minimization and hardware sharing between two consecutive levels.
In addition, hole minimization can ensure a balanced heap structure, which contributes to a reduction in response time.
The replacement operation reduces response time further by substituting a pair of insert and delete operations with one replacement operation that does not create a hole.
As a result, our design achieves a similar performance while offering markedly lower overhead.

The work presented in this paper leaves several directions for future research. For example, we use the binary heap where each node has two children at maximum. In many cases, each node may have $n$ number of items \cite{pq3}. In that case, each node of the heap will have $n$ sorted data (except the last node). Each time an insert or delete operation occurs, we need to maintain the heap construction along with the sorted list of each node.
%Parallel operatons could have many applications, and they could be more complex in terms of FPGA implementation.

\begin{comment}
The work presented in this paper leaves several directions for the future research. We presented some of these ideas here.
 \begin{itemize}
 \item We used the binary heap where each node has maximum two children. In general, each node may have $n$ number of items \cite{pq3}.
In that case, each node of the heap will have $n$ sorted data (except the last node).
For each time of {\it insert} or {\it delete}, we need to assure heap construction along with the sorted list of each node.
There could be abundant parallelism in operations, but the implementation may incur large overhead.
 \item On-chip memory is limited (32 MB in our case, which means $2^{25}$ nodes can be simulated). To make the design more scalable, we can configure this into FPGA-ARM-core where FPGA is integrated into ARM processor. External RAM can be used, keeping in mind that this would lead slow design for extra memory access time.
 \end{itemize}
\end{comment}
